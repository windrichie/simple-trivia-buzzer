# Implementation Tasks: Trivia Buzzer App

**Feature**: 001-trivia-buzzer-app
**Date**: 2026-01-12
**Input**: Generated from spec.md, plan.md, and data-model.md
**Note**: This file is generated by the `/speckit.tasks` command

---

## Task Organization

Tasks are organized by **User Story** with dependencies tracked. Each task follows the format:
- `[ ]` = Not started
- `[P]` = Can be parallelized with other [P] tasks in the same phase
- `[Story]` = User story reference (US1-US6)
- File paths included for clarity

**Priority Legend**:
- **P1** = Critical for MVP (User Stories 1, 2, 5)
- **P2** = Important for full functionality (User Stories 3, 4)
- **P3** = Nice-to-have (User Story 6)

---

## Dependency Graph

```
Phase 1: Setup
    ↓
Phase 2: Foundational (contracts, session manager, Socket.IO)
    ↓
Phase 3: US1 - GM Session Management [MVP]
    ↓
Phase 4: US2 - Buzzer Mechanics (parallel with Phase 5)
    ↓
Phase 5: US5 - Question Flow Management
    ↓
Phase 6: US3 - Score Tracking (parallel with Phase 7)
    ↓
Phase 7: US4 - Player Identification & Reconnection
    ↓
Phase 8: US6 - localStorage Auto-Fill (optional)
    ↓
Phase 9: Polish & Cross-cutting Concerns
```

**Parallel Execution Examples**:
- Phase 1 tasks can all run in parallel after npm workspace setup
- Phase 4 and Phase 5 can be worked on simultaneously (buzzer mechanics + state management)
- Phase 6 and Phase 7 can be worked on simultaneously (scores + reconnection)

---

## MVP Scope

**Minimum Viable Product** = Phase 1 + Phase 2 + Phase 3 (User Story 1)

This delivers:
- Game Master can create session with join code
- Players can join session
- Real-time synchronization between clients
- Basic session management

To test MVP:
1. Start server
2. GM creates session, gets join code
3. Open 3 player tabs, all join with same code
4. Verify all players see each other in the session

---

## Phase 1: Project Setup

**Goal**: Initialize project structure, configure build tools, install dependencies

**Independent Test**: Run `npm run dev` successfully, see backend on :3001 and frontend on :3000

### Tasks

- [x] T001 [P] [Setup] Initialize npm workspaces with root package.json and backend/frontend subdirectories
- [x] T002 [P] [Setup] Create backend/package.json with TypeScript, Express, Socket.IO, nanoid dependencies
- [x] T003 [P] [Setup] Create frontend/package.json with Next.js 14, React 18, Socket.IO client, shadcn/ui, Tailwind CSS
- [x] T004 [P] [Setup] Configure backend/tsconfig.json with ES2022 target, strict mode, Node.js types
- [x] T005 [P] [Setup] Configure frontend/tsconfig.json for Next.js App Router with paths alias
- [x] T006 [P] [Setup] Create .env.example with GM_PASSWORD, PORT, NODE_ENV, NEXT_PUBLIC_WS_URL placeholders
- [x] T007 [P] [Setup] Configure Tailwind CSS in frontend/tailwind.config.ts with mobile-first breakpoints
- [x] T008 [P] [Setup] Initialize shadcn/ui with frontend/components.json config file
- [x] T009 [P] [Setup] Create frontend/app/globals.css with Tailwind directives and shadcn theme variables
- [x] T010 [P] [Setup] Add npm scripts to root package.json: dev (concurrently run both), build, start, test
- [x] T011 [P] [Setup] Create frontend/app/layout.tsx root layout with metadata, font loading via next/font
- [x] T012 [P] [Setup] Create .gitignore with node_modules, dist, .env, .next exclusions

**Checkpoint**: All dependencies installed, TypeScript compiles, dev servers start without errors

---

## Phase 2: Foundational Architecture

**Goal**: Establish shared contracts, core backend services, Socket.IO setup, essential utilities

**Independent Test**: Backend server accepts Socket.IO connections, session manager can create/retrieve sessions

### Tasks

- [x] T013 [P] [Foundation] Copy contracts/websocket-events.ts to backend/src/types/ and frontend/lib/ (shared types)
- [x] T014 [Foundation] Create backend/src/utils/join-code.ts with nanoid-based generator (6 chars, [A-Z2-9])
- [x] T015 [Foundation] Create backend/src/utils/validation.ts with isValidNickname, isValidPassword, isValidJoinCode functions
- [x] T016 [Foundation] Create backend/src/models/session.ts defining GameSession interface
- [x] T017 [Foundation] Create backend/src/models/player.ts defining Player interface
- [x] T018 [Foundation] Create backend/src/models/question.ts defining Question interface
- [x] T019 [Foundation] Create backend/src/session-manager.ts with SessionStore class (Map-based storage, createSession, getSession, deleteSession methods)
- [x] T020 [Foundation] Add cleanup interval to backend/src/session-manager.ts (run every 10min, remove sessions inactive >2hr)
- [x] T021 [Foundation] Create backend/src/server.ts with Express app, Socket.IO server initialization, CORS configuration
- [x] T022 [Foundation] Add Socket.IO connection handler in backend/src/server.ts with typed events (ClientToServerEvents, ServerToClientEvents)
- [x] T023 [P] [Foundation] Create frontend/lib/socket.ts with Socket.IO client setup using NEXT_PUBLIC_WS_URL
- [x] T024 [P] [Foundation] Create frontend/hooks/use-socket.ts React hook for Socket.IO connection management
- [x] T025 [P] [Foundation] Create frontend/app/providers.tsx with SocketProvider wrapping children for global socket context

**Checkpoint**: Backend server starts, accepts connections, can create/store sessions in memory, frontend can connect via WebSocket

---

## Phase 3: User Story 1 - GM Session Management [P1] [MVP]

**Goal**: Game Master can create sessions with join codes, players can join, real-time synchronization works

**Independent Test**: GM creates session → receives join code → players join → all see each other in session

### Backend Tasks

- [x] T026 [US1] Create backend/src/event-handlers/gm-handlers.ts with handleCreateSession function
- [x] T027 [US1] Implement GM password validation in handleCreateSession (compare with process.env.GM_PASSWORD)
- [x] T028 [US1] Generate unique join code in handleCreateSession, retry if collision detected
- [x] T029 [US1] Create new GameSession in session manager with generated join code, emit session:created to GM
- [x] T030 [US1] Implement handleEndSession in gm-handlers.ts to set isActive=false, broadcast session:ended to all clients
- [x] T031 [US1] Create backend/src/event-handlers/player-handlers.ts with handleJoin function
- [x] T032 [US1] Validate join code, session capacity (<5 players), nickname uniqueness in handleJoin
- [x] T033 [US1] Create Player entity with UUID playerId, add to session.players Map in handleJoin
- [x] T034 [US1] Join player socket to Socket.IO room (joinCode as room name) in handleJoin
- [x] T035 [US1] Broadcast player:joined event to all clients in room after successful join
- [x] T036 [US1] Handle player disconnect event: mark player.isConnected=false, broadcast player:disconnected

### Frontend Tasks

- [x] T037 [P] [US1] Install shadcn/ui components: Button, Card, Input, Label, Toast
- [x] T038 [US1] Create frontend/app/page.tsx home page with navigation buttons to /gamemaster and /player
- [x] T039 [US1] Create frontend/app/gamemaster/page.tsx with password input form
- [x] T040 [US1] Implement gm:createSession emit in gamemaster page, display join code on successful response
- [x] T041 [US1] Display current session state (players list) in gamemaster page, listen to player:joined events
- [x] T042 [US1] Add "End Session" button in gamemaster page, emit gm:endSession on click
- [x] T043 [US1] Create frontend/app/player/page.tsx with join form (join code, nickname, password inputs)
- [x] T044 [US1] Implement player:join emit in player page, handle success/error callbacks
- [x] T045 [US1] Display "Joined Session" confirmation with player nickname after successful join
- [x] T046 [US1] Create frontend/components/player-list.tsx component to display all players in session
- [x] T047 [US1] Listen to player:joined and player:disconnected events in player page to update UI

**Checkpoint**: Complete user flow works: GM creates session → players join → all see live player list → session can be ended

---

## Phase 4: User Story 2 - Buzzer Mechanics [P1]

**Goal**: Players can press buzzer, sound plays, first press is identified and displayed

**Independent Test**: Start question → 3 players buzz → system identifies first buzzer → sounds play on all devices

### Backend Tasks

- [x] T048 [US2] Implement handlePressBuzzer in player-handlers.ts
- [x] T049 [US2] Validate gameState === ACTIVE in handlePressBuzzer, return BUZZER_DISABLED error if wrong state
- [x] T050 [US2] Check if player already buzzed for current question (lastBuzzTimestamp), return ALREADY_BUZZED error if duplicate
- [x] T051 [US2] Timestamp buzzer press with Date.now(), add BuzzerEvent to currentQuestion.buzzerPresses array
- [x] T052 [US2] Determine if this is first press by comparing timestamps, handle ties with random selection
- [x] T053 [US2] Broadcast buzzer:pressed event to all clients in room with player info and timestamp
- [x] T054 [US2] Broadcast buzzer:first event if this is the first press, include playerId and playerName
- [x] T055 [US2] Implement handleChangeBuzzerSound in player-handlers.ts to update player.buzzerSound

### Frontend Tasks

- [x] T056 [P] [US2] Create frontend/public/sounds/ directory and add 10 buzzer sound files (MP3 + OGG fallback)
- [x] T057 [P] [US2] Install or configure shadcn/ui Select component for sound picker
- [x] T058 [US2] Create frontend/lib/audio.ts with preloadAudio function to load all sounds on page mount
- [x] T059 [US2] Create frontend/hooks/use-audio.ts hook with playSound function using HTML5 Audio API
- [x] T060 [US2] Create frontend/components/buzzer-button.tsx with large circular button (h-48 w-48 rounded-full)
- [x] T061 [US2] Add touchstart event handler to buzzer button for mobile with no 300ms delay
- [x] T062 [US2] Play sound locally immediately when buzzer pressed (client-side, no server round-trip)
- [x] T063 [US2] Emit player:pressBuzzer event to server on button press
- [x] T064 [US2] Listen to buzzer:first event, display visual indicator showing first player (name + badge)
- [x] T065 [US2] Listen to buzzer:pressed events, update UI showing all players who buzzed with timestamps
- [x] T066 [US2] Create buzzer sound selector dropdown in player page using Select component
- [x] T067 [US2] Emit player:changeBuzzerSound when player selects new sound, preview sound on selection
- [x] T068 [US2] Disable buzzer button when gameState !== ACTIVE, show "Wait for question" message

**Checkpoint**: Players can buzz, sounds play immediately, first buzzer identified correctly, all players see buzzer order

---

## Phase 5: User Story 5 - Question Flow Management [P1]

**Goal**: GM controls question states (waiting/active/scoring), players can only buzz in ACTIVE state

**Independent Test**: GM starts question → state becomes ACTIVE → players buzz → GM moves to scoring → state becomes SCORING

### Backend Tasks

- [ ] T069 [US5] Implement handleStartQuestion in gm-handlers.ts
- [ ] T070 [US5] Create new Question object with questionNumber (increment from previous), state=ACTIVE, startedAt timestamp
- [ ] T071 [US5] Set session.currentQuestion to new question, update session.gameState to ACTIVE
- [ ] T072 [US5] Reset all players' lastBuzzTimestamp to null when starting new question
- [ ] T073 [US5] Broadcast game:questionStarted and game:stateChanged events to all clients in room
- [ ] T074 [US5] Implement handleMoveToScoring in gm-handlers.ts
- [ ] T075 [US5] Validate at least 1 buzzer press exists in currentQuestion.buzzerPresses, return NO_BUZZER_PRESSES error if empty
- [ ] T076 [US5] Update session.gameState to SCORING, broadcast game:scoringStarted and game:stateChanged events
- [ ] T077 [US5] Implement handleSkipQuestion in gm-handlers.ts
- [ ] T078 [US5] Transition from ACTIVE → WAITING, reset currentQuestion to null, broadcast game:questionSkipped
- [ ] T079 [US5] After scoring complete, transition SCORING → WAITING when GM clicks "Next Question"

### Frontend Tasks

- [ ] T080 [P] [US5] Create frontend/components/game-state-indicator.tsx component displaying current state badge
- [ ] T081 [US5] Add "Start Question" button to gamemaster page, emit gm:startQuestion on click
- [ ] T082 [US5] Add "Move to Scoring" button to gamemaster page (enabled only when state=ACTIVE), emit gm:moveToScoring
- [ ] T083 [US5] Add "Skip Question" button to gamemaster page (enabled only when state=ACTIVE), emit gm:skipQuestion
- [ ] T084 [US5] Display error toast if GM tries to move to scoring with no buzzes
- [ ] T085 [US5] Listen to game:stateChanged event in both GM and player pages, update UI state indicators
- [ ] T086 [US5] Update buzzer button disabled state based on gameState (enabled only when ACTIVE)
- [ ] T087 [US5] Show question number in GM interface, increment on each new question

**Checkpoint**: GM can control entire question flow, state transitions work correctly, players can only buzz when allowed

---

## Phase 6: User Story 3 - Score Tracking [P2]

**Goal**: GM assigns points to players, scores update in real-time across all clients

**Independent Test**: After scoring starts → GM assigns +10 to player A, -5 to player B → both scores update everywhere

### Backend Tasks

- [ ] T088 [US3] Implement handleAssignPoints in gm-handlers.ts
- [ ] T089 [US3] Validate gameState === SCORING, return INVALID_STATE_TRANSITION error if wrong state
- [ ] T090 [US3] Validate points within range (-1000 to +1000) using VALIDATION.SCORE constants
- [ ] T091 [US3] Update player.score by adding points (can result in negative score)
- [ ] T092 [US3] Broadcast player:scoreUpdated event to all clients with playerId, newScore, pointsAdded

### Frontend Tasks

- [ ] T093 [P] [US3] Update frontend/components/player-list.tsx to display scores next to each player name
- [ ] T094 [US3] Create score assignment UI in gamemaster page (list of players with +/- point buttons)
- [ ] T095 [US3] Add quick point buttons: +10, +5, -5, -10 for common point values
- [ ] T096 [US3] Add custom point input field in GM interface for non-standard point values
- [ ] T097 [US3] Emit gm:assignPoints when GM clicks point buttons with playerId and points
- [ ] T098 [US3] Display large score card in player page showing "Your Score: X" prominently
- [ ] T099 [US3] Listen to player:scoreUpdated event, update score displays with animation (color flash on change)
- [ ] T100 [US3] Show all players' scores in both GM view and player view (sorted by score descending)

**Checkpoint**: Scores update in real-time, players see their own score and others' scores, GM can assign positive/negative points

---

## Phase 7: User Story 4 - Player Identification & Reconnection [P2]

**Goal**: Players set passwords on join, can reconnect after disconnect with preserved scores

**Independent Test**: Player joins → notes score → closes tab → reopens → rejoins with password → score restored

### Backend Tasks

- [ ] T101 [US4] Update handleJoin in player-handlers.ts to require password field, validate length (4-20 chars)
- [ ] T102 [US4] Store plain-text password in Player entity (acceptable for casual in-memory game)
- [ ] T103 [US4] Implement handleRejoin in player-handlers.ts
- [ ] T104 [US4] Validate reconnection credentials: match player by (joinCode, nickname, password) triple
- [ ] T105 [US4] Return AUTHENTICATION_FAILED error if credentials don't match existing player
- [ ] T106 [US4] Update player.connectionId to new socket ID, set player.isConnected = true
- [ ] T107 [US4] Broadcast player:reconnected event to all clients in room
- [ ] T108 [US4] Return full player state (score, buzzerSound) in rejoin callback to restore UI

### Frontend Tasks

- [ ] T109 [US4] Update join form in player page to require password field (4-20 character validation)
- [ ] T110 [US4] Show password input with "Set a password for reconnection" helper text
- [ ] T111 [US4] Display client-side validation errors for nickname (1-20 chars, alphanumeric) and password (4-20 chars)
- [ ] T112 [US4] Add "Rejoin Session" button/mode in player page if player was previously connected
- [ ] T113 [US4] Emit player:rejoin event when reconnecting with saved credentials
- [ ] T114 [US4] Handle rejoin callback: restore score, buzzerSound, and session state on success
- [ ] T115 [US4] Display error toast on authentication failure ("Incorrect nickname or password")
- [ ] T116 [US4] Listen to player:reconnected event, show toast notification "X has reconnected"

**Checkpoint**: Players can disconnect and rejoin with preserved state, authentication works correctly

---

## Phase 8: User Story 6 - localStorage Auto-Fill [P3] (Optional)

**Goal**: Save credentials to localStorage after join, auto-fill form on return

**Independent Test**: Join session → close tab → reopen → form pre-filled with saved credentials

### Frontend Tasks

- [ ] T117 [P] [US6] Create frontend/hooks/use-local-storage.ts hook with get/set/clear functions
- [ ] T118 [US6] Save joinCode, nickname, password to localStorage after successful player:join
- [ ] T119 [US6] Load credentials from localStorage on player page mount, pre-fill join form fields
- [ ] T120 [US6] Add "Clear Saved Credentials" button in player page to clear localStorage
- [ ] T121 [US6] Show visual indicator when credentials are auto-filled ("Credentials restored from last session")
- [ ] T122 [US6] Auto-detect if session is still active when credentials found, show "Rejoin" button instead of "Join"

**Checkpoint**: Credentials persist across browser sessions, form auto-fills, users can clear saved data

---

## Phase 9: Polish & Cross-cutting Concerns

**Goal**: Production readiness, deployment configuration, mobile optimizations, error handling

**Independent Test**: Deploy to Fly.io, test on mobile devices, verify error handling works

### Production & Deployment

- [ ] T123 [P] [Polish] Configure Next.js production build in frontend/next.config.js (standalone mode)
- [ ] T124 [P] [Polish] Create backend build script using tsc to compile TypeScript to dist/
- [ ] T125 [P] [Polish] Update root package.json build script to build both frontend and backend
- [ ] T126 [P] [Polish] Create production start script to run backend server serving Next.js static files
- [ ] T127 [P] [Polish] Add /health endpoint in backend for Fly.io health checks
- [ ] T128 [P] [Polish] Configure CORS for production domain in backend/src/server.ts
- [ ] T129 [P] [Polish] Add helmet.js middleware for security headers
- [ ] T130 [P] [Polish] Create Dockerfile with Node.js 22-alpine base image, multi-stage build
- [ ] T131 [P] [Polish] Create fly.toml configuration with app name, region, auto_stop_machines=false for WebSocket
- [ ] T132 [P] [Polish] Update README.md with Fly.io deployment instructions (flyctl install, launch, deploy)

### Mobile Optimizations

- [ ] T133 [P] [Polish] Add viewport meta tag with maximum-scale=1 to prevent zoom on input focus
- [ ] T134 [P] [Polish] Add overscroll-behavior: none to body in globals.css to disable pull-to-refresh
- [ ] T135 [P] [Polish] Implement Vibration API feedback on buzzer press for mobile tactile response
- [ ] T136 [P] [Polish] Test touch targets minimum 44x44px on all interactive elements (buttons, inputs)
- [ ] T137 [P] [Polish] Add loading states with skeletons for slow network connections
- [ ] T138 [P] [Polish] Test audio playback permissions on mobile Safari and Chrome

### Error Handling & Edge Cases

- [ ] T139 [P] [Polish] Add error boundaries in Next.js using error.tsx in app directory
- [ ] T140 [P] [Polish] Implement toast notifications for all error scenarios (session not found, full, etc.)
- [ ] T141 [P] [Polish] Add loading spinners during async operations (joining, creating session)
- [ ] T142 [P] [Polish] Handle server disconnect gracefully with "Reconnecting..." message
- [ ] T143 [P] [Polish] Test and handle race conditions: simultaneous joins, rapid buzzer presses
- [ ] T144 [P] [Polish] Add rate limiting on server for buzzer presses (prevent spam)

### UI/UX Polish

- [ ] T145 [P] [Polish] Add animations for score updates (smooth number transitions)
- [ ] T146 [P] [Polish] Add sound effect preview when selecting buzzer sounds
- [ ] T147 [P] [Polish] Improve mobile layout for gamemaster page (responsive card grid)
- [ ] T148 [P] [Polish] Add dark mode support using shadcn/ui theme variables (optional)
- [ ] T149 [P] [Polish] Display session join code as large, easy-to-read text for verbal communication
- [ ] T150 [P] [Polish] Add copy-to-clipboard button for join code in GM interface

**Checkpoint**: App is production-ready, mobile-optimized, handles errors gracefully, deployed successfully

---

## Task Summary

**Total Tasks**: 150
- Phase 1 (Setup): 12 tasks
- Phase 2 (Foundational): 13 tasks
- Phase 3 (US1 - MVP): 22 tasks
- Phase 4 (US2): 21 tasks
- Phase 5 (US5): 19 tasks
- Phase 6 (US3): 13 tasks
- Phase 7 (US4): 16 tasks
- Phase 8 (US6): 6 tasks
- Phase 9 (Polish): 28 tasks

**Estimated MVP Completion**: Phase 1-3 = 47 tasks (31% of total)
**Estimated Full P1/P2 Completion**: Phase 1-7 = 116 tasks (78% of total)

---

## Execution Strategy

### For MVP (Phases 1-3):
1. Complete Phase 1 setup (can parallelize most tasks after workspace init)
2. Complete Phase 2 foundations sequentially (dependencies between tasks)
3. Complete Phase 3 backend first, then frontend tasks in parallel where marked [P]

### For Full Implementation:
1. After Phase 3, work on Phase 4 and Phase 5 in parallel (different developers or sequential)
2. After Phase 5 complete, work on Phase 6 and Phase 7 in parallel
3. Phase 8 is optional (P3 priority) - can be deferred
4. Phase 9 polish tasks can start once core functionality works

### Parallel Work Examples:
- Phase 1: T001 (workspace) → then T002-T012 all in parallel
- Phase 2: T023-T025 (frontend socket) can run while T013-T022 (backend) completes
- Phase 4 & 5: Different developers can work simultaneously on buzzer vs state management
- Phase 9: All Polish tasks marked [P] can be distributed across team members

---

## Validation Checklist

After completing each phase:

**Phase 1**: ✓ `npm run dev` starts both servers without errors
**Phase 2**: ✓ WebSocket connection established, session created in memory
**Phase 3**: ✓ GM creates session, 3 players join, all see each other
**Phase 4**: ✓ Players buzz, sounds play, first buzzer identified
**Phase 5**: ✓ GM controls question flow, state transitions work
**Phase 6**: ✓ Scores update in real-time across all clients
**Phase 7**: ✓ Players reconnect with password, scores preserved
**Phase 8**: ✓ Credentials auto-fill from localStorage
**Phase 9**: ✓ Production build deploys to Fly.io, mobile testing passes, WebSocket connections persist during 1-2 hour games

---

**Tasks Complete**: Ready for implementation with `/speckit.implement` or manual execution
